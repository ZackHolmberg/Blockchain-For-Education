package blockchain

import (
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"log"
	"strconv"
	"strings"
	"time"
)

// ============================ Proof of Work ============================

// ProofOfWork algorithm used in mining blocks
type ProofOfWork struct {
	ProofDifficulty int
	CandidateBlock  Block
	mining          bool
}

// Initialize is the interface method that calls this component's initialize method
func (p ProofOfWork) Initialize() error {
	// No initialization needed for this implementation
	return nil
}

// Terminate is the interface method that calls this component's cleanup method
func (p ProofOfWork) Terminate() {
	// No clean-up needed for this implementation
}

// Terminate is the interface method that calls this component's cleanup method
func (p ProofOfWork) GetCandidateBlock() Block {
	return p.CandidateBlock
}

// HandleCommand is the interface method that handles the passed message
func (p *ProofOfWork) HandleCommand(msg Message, peer *Peer) (err error) {

	switch msg.Command {
	case "MINE":
		go func() {
			// Start a new mining session
			newTransaction := msg.Data.(Transaction)
			p.mining = true
			p.CandidateBlock = Block{}
			log.Println("Recieved a new transaction, beginning new mining session...")

			//Create a new block
			newBlock := Block{
				Index:     len(peer.chain),
				Timestamp: time.Now().String(),
				Data:      newTransaction,
				PrevHash:  peer.chain[len(peer.chain)-1].Hash,
				Hash:      "",
				Nonce:     0}

			//Calculate this block's proof
			newBlock = p.proofOfWork(newBlock, p.mining)

			if p.mining {
				p.mining = false
			}

			// If the new block's hash isnt empty, then this peer successfully mined the block
			if newBlock.Hash != "" {
				log.Println("Block mined successfully")

				p.CandidateBlock = newBlock
				data := CandidateBlock{Block: newBlock}

				log.Println("Sending proof to Middleware for validation...")

				toSend, err := peer.communicationComponent.GenerateMessage("PROOF", data)
				if err != nil {
					log.Printf("Fatal error generating message: %v\n", err)
					return
				}

				err = peer.communicationComponent.SendMsgToPeer(toSend, peer.communicationComponent.GetMiddlewarePeer())
				if err != nil {
					log.Printf("Error sending message to Middleware: %v\n", err)
					return
				}
			}
		}()

	case "CONSENSUS":
		go func() {
			if p.mining {
				// Set mining to false which will end the mining session
				// as another peer has already successfully mined the block
				p.mining = false
			}

			// Broadcast this peer's copy of the chain so that the new chain can be distributed
			data := Chain{ChainCopy: peer.chain}

			toSend, err := peer.communicationComponent.GenerateMessage("PEER_CHAIN", data)
			if err != nil {
				log.Printf("Error generating message: %v\n", err)
			}

			err = peer.communicationComponent.BroadcastMsgToNetwork(toSend)
			if err != nil {
				log.Printf("Error broadcasting message: %v\n", err)
			}

		}()

	default:
		err = errors.New("command not supported")
	}

	return err

}

// ValidateBlock is an interface method that verifies that the proof generated by this component's proof method is a valid proof for the block
func (p ProofOfWork) ValidateBlock(b Block) bool {
	if len(b.Hash) < p.ProofDifficulty {
		return false
	}

	return b.Hash[:p.ProofDifficulty] == strings.Repeat("0", p.ProofDifficulty) && b.Hash == p.CalculateHash(b)

}

// CalculateHash is the interface method that calculates a hash given some data
func (p ProofOfWork) CalculateHash(b Block) string {
	record := strconv.Itoa(b.Index) + b.Timestamp + b.Data.ToString() + b.PrevHash + strconv.Itoa(b.Nonce)
	h := sha256.New()
	h.Write([]byte(record))
	hashed := h.Sum(nil)
	return hex.EncodeToString(hashed)
}

// proofOfWork is the consensus algorithm that computes a satisfactory hash for the passed block
func (p ProofOfWork) proofOfWork(b Block, m bool) Block {

	b.Nonce = 0
	for !p.ValidateBlock(b) && m {
		b.Nonce++
		b.Hash = p.CalculateHash(b)
	}
	return b
}
