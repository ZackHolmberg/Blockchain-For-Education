package blockchain

import (
	"crypto/sha256"
	"encoding/hex"
	"strconv"
	"strings"
)

// ============================ Proof of Work ============================

// ProofOfWork algorithm used in mining blocks
type ProofOfWork struct {
	ProofDifficulty int
}

// ProofMethod is the interface method that calls this component's proof method
func (p ProofOfWork) ProofMethod(b Block) string {
	return proofOfWork(p, b)
}

// proofOfWork is the proof of work algorithm that
func proofOfWork(p ProofOfWork, b Block) string {
	nonce := 0
	proof := ""
	for !p.ValidateProof(proof) {
		proof = p.CalculateHash(nonce, b)
		nonce++
	}
	return proof
}

// ValidateProof verifies that the proof generated by this component's proof method is a valid proof
func (p ProofOfWork) ValidateProof(proofAttempt string) bool {
	if len(proofAttempt) < p.ProofDifficulty {
		return false
	}
	return proofAttempt[:p.ProofDifficulty] == strings.Repeat("0", p.ProofDifficulty)
}

// CalculateHash is the interface method that caluclates a hash given some data
func (p ProofOfWork) CalculateHash(nonce int, block Block) string {
	record := strconv.Itoa(block.Index) + block.Timestamp + block.Data.ToString() + block.PrevHash + strconv.Itoa(nonce)
	h := sha256.New()
	h.Write([]byte(record))
	hashed := h.Sum(nil)
	return hex.EncodeToString(hashed)
}
