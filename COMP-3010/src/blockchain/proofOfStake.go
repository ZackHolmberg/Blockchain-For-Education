package blockchain

import (
	"crypto/sha256"
	"encoding/hex"
	"strconv"
	"strings"
)

// ============================ Proof of Work ============================

// ProofOfStake algorithm used in mining blocks
type ProofOfStake struct {
	ProofDifficulty int
}

// Initialize is the interface method that calls this component's initialize method
func (p ProofOfStake) Initialize() error {
	// No initialization needed for this implementation
	return nil
}

// Terminate is the interface method that calls this component's cleanup method
func (p ProofOfStake) Terminate() {
	// No clean-up needed for this implementation
}

// ProofMethod is the interface method that calls this component's proof method
func (p ProofOfStake) ProofMethod(b Block, m bool) string {
	return p.proofOfStake(b, m)
}

// proofOfStake is the proof of work algorithm that
func (p ProofOfStake) proofOfStake(b Block, mining bool) string {

	nonce := 0
	proof := ""
	for !p.ValidateProof(proof) && mining {
		proof = p.CalculateHash(nonce, b)
		nonce++
	}
	return proof
}

// ValidateProof verifies that the proof generated by this component's proof method is a valid proof
func (p ProofOfStake) ValidateProof(proofAttempt string) bool {
	if len(proofAttempt) < p.ProofDifficulty {
		return false
	}
	return proofAttempt[:p.ProofDifficulty] == strings.Repeat("0", p.ProofDifficulty)
}

// CalculateHash is the interface method that caluclates a hash given some data
func (p ProofOfStake) CalculateHash(nonce int, block Block) string {
	record := strconv.Itoa(block.Index) + block.Timestamp + block.Data.ToString() + block.PrevHash + strconv.Itoa(nonce)
	h := sha256.New()
	h.Write([]byte(record))
	hashed := h.Sum(nil)
	return hex.EncodeToString(hashed)
}
