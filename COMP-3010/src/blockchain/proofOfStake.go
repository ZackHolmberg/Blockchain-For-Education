package blockchain

import (
	"crypto/sha256"
	"encoding/hex"
	"log"
	"strconv"
	"time"
)

// ============================ Proof of Work ============================

// ProofOfStake algorithm used in mining blocks
type ProofOfStake struct {
	StakeAmount    int
	CandidateBlock Block
	toMine         Transaction
}

// Initialize is the interface method that calls this component's initialize method
func (p ProofOfStake) Initialize() error {
	// No initialization needed for this implementation
	return nil
}

// Terminate is the interface method that calls this component's cleanup method
func (p ProofOfStake) Terminate() {
	// No clean-up needed for this implementation
}

// Terminate is the interface method that calls this component's cleanup method
func (p ProofOfStake) GetCandidateBlock() Block {
	return p.CandidateBlock
}

// HandleCommand is the interface method that handles the passed message
func (p *ProofOfStake) HandleCommand(msg Message, peer *Peer) (err error) {

	switch msg.Command {
	case "MINE":
		go func() {
			// Start a new mining session by sending stake to middleware
			log.Println("Starting new mining session, entering lottery...")

			// Mine the new block
			p.toMine = msg.Data.(Transaction)

			// Enter the lottery with a stake of currency (equal to 50% of the current wallet amount, rounded to an int
			stake := int(peer.wallet / 2)
			peer.wallet -= stake

			data := LotteryEntry{Stake: stake}

			toSend, err := peer.communicationComponent.GenerateMessage("STAKE", data)
			if err != nil {
				log.Printf("Fatal error generating message: %v\n", err)
				return
			}

			err = peer.communicationComponent.SendMsgToPeer(toSend, peer.communicationComponent.GetMiddlewarePeer())
			if err != nil {
				log.Printf("Error sending message to Middleware: %v\n", err)
				return
			}
		}()
	case "WINNER":
		go func() {
			p.CandidateBlock = Block{}
			log.Println("Won the lottery and recieved a new transaction, beginning new mining session...")

			//Create a new block
			newBlock := Block{
				Index:     len(peer.chain),
				Timestamp: time.Now().String(),
				Data:      p.toMine,
				PrevHash:  peer.chain[len(peer.chain)-1].Hash,
				Hash:      "",
				Nonce:     0}

			//Calculate this block's proof
			newBlock.Hash = p.CalculateHash(newBlock)

			log.Println("Block mined successfully")

			p.CandidateBlock = newBlock
			data := CandidateBlock{Block: newBlock}

			log.Println("Sending proof to Middleware...")

			// TODO: Would need to send the proposed block here for validation to occur
			toSend, err := peer.communicationComponent.GenerateMessage("PROOF", data)
			if err != nil {
				log.Printf("Fatal error generating message: %v\n", err)
				return
			}

			err = peer.communicationComponent.SendMsgToPeer(toSend, peer.communicationComponent.GetMiddlewarePeer())
			if err != nil {
				log.Printf("Error sending message to Middleware: %v\n", err)
				return
			}

		}()
	case "CONSENSUS":
		go func() {

			// Broadcast this peer's copy of the chain so that the new chain can be distributed
			data := Chain{ChainCopy: peer.chain}

			toSend, err := peer.communicationComponent.GenerateMessage("PEER_CHAIN", data)
			if err != nil {
				log.Printf("Error generating message: %v\n", err)
			}

			err = peer.communicationComponent.BroadcastMsgToNetwork(toSend)
			if err != nil {
				log.Printf("Error broadcasting message: %v\n", err)
			}

		}()
	case "STAKE":
		go func() {

			// Accept the stake refund from the middleware, add staked amount back into wallet
			data := msg.Data.(LotteryEntry)
			peer.wallet += data.Stake
			log.Println("Received stake back from Middleware, new wallet balance: ", peer.wallet)

		}()

	default:
		log.Println("Warning: Command \"" + msg.Command + "\" not supported")
	}

	return

}

// ValidateBlock is an interface method that verifies that the proof generated by this component's proof method is a valid proof for the block
func (p ProofOfStake) ValidateBlock(b Block) bool {
	return b.Hash == p.CalculateHash(b)
}

// CalculateHash is the interface method that calculates a hash given some data
func (p ProofOfStake) CalculateHash(b Block) string {
	record := strconv.Itoa(b.Index) + b.Timestamp + b.Data.ToString() + b.PrevHash + strconv.Itoa(b.Nonce)
	h := sha256.New()
	h.Write([]byte(record))
	hashed := h.Sum(nil)
	return hex.EncodeToString(hashed)
}
